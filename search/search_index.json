{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Catwork","text":"<p> Download Catwork</p> <p> Learn what Catwork has to offer! </p>"},{"location":"#catworkdoc-noMarginBig","title":"Catwork","text":"<p>The cat framework, written by cats, for cats!</p> <p>Catwork is a tiny, ergonomic, declarative framework for creating runtime code.</p>"},{"location":"#weave-dependencies-with-asynchronous-design-patterns","title":"Weave dependencies with asynchronous design patterns.","text":"<p>Catwork implements all of its code through Fragments! These allow you to manage dependencies in a simple and easy to understand way!</p> MeowService.lua<pre><code>return Catwork.Fragment {\n    Init = function(self)\n        task.wait(1)\n        self.Value = \"cat\"\n    end,\n\n    ConsumeValue = function(self)\n        print(self.Value)\n    end\n}\n</code></pre> <pre><code>local MeowService = require(script.MeowService)\n\nMeowService:Await() -- waits for the service to initialise before grabbing the value\n\n-- If we called this without awaiting, it'd print nothing, Catwork wraps messy\n-- asynchronous design behind `Await` and `HandleAsync`\nMeowService:ConsumeValue()\n</code></pre>"},{"location":"#you-build-the-framework","title":"You build the framework!","text":"<p>Catwork exports an object called a <code>Service</code>, this lets you add almost any behaviour to Fragments beyond what Catwork originally allows.</p> RemoteService.lua<pre><code>return Catwork.Service {\n    Name = \"RemoteService\",\n\n    Fragment = function(self, params)\n        params.Remote = makeRemote(params)\n        return Catwork:CreateFragmentForService(params, self)\n    end,\n\n    Spawning = function(self, f)\n        if f.RemoteConnection then\n            f.Remote.OnServer:Connect(f.RemoteConnection)\n        end\n    end\n}\n</code></pre> <pre><code>local MeowRemote = RemoteService:Fragment {\n    Name = \"MeowRemote\",\n\n    RemoteConnection = function(plr)\n        print(`meows as {plr.Name} cutely`)\n    end\n}\n</code></pre>"},{"location":"#run-fragments-anywhere","title":"Run Fragments, anywhere.","text":"<p>Catwork doesn't care about what you return, only that you call one of it's constructors.</p> <p>This means as long as the code is executed, you can create a Fragment just about anywhere, a ModuleScript? A Script? Go for it!</p> LocalScript in ReplicatedFirst<pre><code>local Catwork = require(ReplicaedFirst.Catwork)\n\nlocal LoadingScreenManager = Catwork.Fragment {\n    Name = \"LoadingScreenManager\",\n\n    Init = function()\n        ReplicatedFirst:RemoveDefaultLoadingScreen()\n        -- code to execute guis or whatever\n    end\n}\n</code></pre>"},{"location":"#lets-go-on-an-adventure-together","title":"Lets go on an adventure together","text":"<p>Ready to start with Catwork? Then lets go into the tutorials!</p>"},{"location":"migration5/","title":"Migrating to 0.5.0","text":"<p>Note</p> <p>This migration guide is hosted here during the release candidate phases of development, but will be moved into the main documentation site once 0.5.0 docs are fully baked.</p>"},{"location":"migration5/#fragment-catworkasyncobject","title":"Fragment -&gt; CatworkAsyncObject","text":"<p>Fragment has been renamed to CatworkAsyncObject, this has changed several APIs. This change was made to better reflect how these objects work, since the name <code>Fragment</code> is a leftover from the Tabby days.</p>"},{"location":"migration5/#constructing-objects","title":"Constructing objects","text":"<p>This is simply a rename from <code>Catwork.Fragment</code> to <code>Catwork.new</code>, to construct objects from services, use the newly added <code>Service.CreateObject</code> method, which replaces <code>Service.Fragment</code>.</p>"},{"location":"migration5/#service-callbacks-regarding-catworkasyncobject","title":"Service Callbacks regarding CatworkAsyncObject","text":"<p>Service callbacks and methods have simply been renamed from <code>Fragment[X]</code> to <code>Object[X]</code></p> <p>These are:</p> <ul> <li><code>Service.Fragment</code> -&gt; <code>Service.Object</code></li> <li><code>Service.CreateFragmentFromObject</code> -&gt; <code>Service.CreateObjectFromClass</code><ul> <li>See also; <code>Template -&gt; Class</code></li> </ul> </li> <li><code>Service.FragmentAdded</code> -&gt; <code>Service.ObjectAdded</code></li> <li><code>Service.FragmentRemoved</code> -&gt; <code>Service.ObjectRemoved</code></li> </ul>"},{"location":"migration5/#template-class","title":"Template -&gt; Class","text":"<p>Templates have been renamed to Classes, the only callback within services here that needs to be changed is <code>Service.Template</code> to <code>Service.Class</code>, its worth noting that this function has a different signature.</p> <p>Converting templates to classes</p> Old Template ConstructionNew Class Construction <pre><code>return TemplateService:Template {\n    Name = \"Meowitzer\",\n    CreateFragment = function(fragment)\n        function fragment:Init()\n            print(\"meow!\")\n        end\n    end\n}\n</code></pre> <pre><code>return TemplateService:Class(\"Meowitzer\", function(object)\n    function object:Init()\n        print(\"meow!\")\n    end\nend)\n</code></pre>"},{"location":"migration5/#changes-to-timeoutdisabled-and-similar-keys","title":"Changes to <code>TimeoutDisabled</code> and similar keys","text":"<p>Catwork will now define these keys using the newly added <code>meta</code> function, this was done to better isolate internal Catwork keys.</p> <p>Old</p> OldNew <pre><code>return Catwork.Fragment {\n    TimeoutDisabled = true\n}\n</code></pre> <pre><code>return Catwork.new {\n    [meta \"TimeoutDisabled\"] = true\n}\n</code></pre> <p>All keys which have been converted to use the <code>meta</code> function are listed here</p> <pre><code>EnableClasses\nTimeoutDisabled\n\n# these are new metakeys but added here regardless\nAwaitFor\nEnableUpdating\nPluginMetadata\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This is a reference for methods within Catwork. These explain the inner workings of Catwork's fundamental concepts.</p> <p>Technical Reference</p> <p>These references are designed as a technical reference and may go into depths on some concepts, as stated before, refer to tutorials for more beginner friendly introductions.</p>"},{"location":"reference/errors/","title":"Errors","text":"<p>This is a reference document for all errors.</p> <p>Todo</p> <p>This should be referenced to in the ERROR module</p>"},{"location":"reference/errors/#bad_arg","title":"BAD_ARG","text":"<ul> <li>Message : <code>Bad argument number %s to function %q. Expected %s, got %s</code></li> <li>Severity: <code>Error</code></li> </ul> <p>An argument was passed to a function that doesn't match an expected type.</p> <pre><code>Catwork.Fragment(\"cat\") -- Not OK\nCatwork.Fragment {} -- OK\n</code></pre>"},{"location":"reference/errors/#bad_object","title":"BAD_OBJECT","text":"<ul> <li>Message: <code>Bad argument number %s to function %s. Type %s could not be converted into object %s.</code></li> <li>Severity: <code>Error</code></li> </ul> <p>Catwork uses internal headers to identify what tables you're passing to functions. This error emits when an incorrect object was passed.</p> <pre><code>Catwork:CreateFragmentForService({}, {}) -- Not OK, expects Service on second arg\nCatwork:CreateFragmentForService({}, SomeService) -- OK\n</code></pre>"},{"location":"reference/errors/#bad_self_call","title":"BAD_SELF_CALL","text":"<ul> <li>Message: <code>Bad self call to %q, did you mean to use : instead of .?</code></li> <li>Severity: <code>Error</code></li> </ul> <p>For some methods, we can evaluate specifically if you've sent the correct object as <code>self</code> in the method. When you do <code>:</code> calling, this isn't an issue, however, if you call with <code>.</code>, for example, inside a pcall, you must also pass the table as <code>self</code></p> <p>More information on method call sugar syntax</p> <p>Note</p> <p>You should generally use <code>:</code> syntax where possible on methods where it is defined, because its actually slightly faster. You should only fallback to <code>.</code>, if you're trying to index the function, for example, inside a pcall</p> <pre><code>pcall(Catwork.GetFragmentsOfName, Catwork, \"cat\")\n</code></pre> <pre><code>Catwork.GetFragmentsOfName(\"cat\") -- Not OK, self was not passed\nCatwork.GetFragmentsOfName({}, \"cat\") -- Not OK, wrong object was not passed\nCatwork.GetFragmentsOfName(Catwork, \"cat\") -- OK, catwork passed as self\nCatwork:GetFragmentsOfName(\"cat\") -- OK, method call syntax\n</code></pre>"},{"location":"reference/errors/#bad_table_shape","title":"BAD_TABLE_SHAPE","text":"<ul> <li>Message: <code>Object %* cannot be converted to %s. Type of key %s is invalid. Expected %q, got %q.</code></li> <li>Severity: <code>Error</code></li> </ul> <p>The <code>Catwork.Fragment</code> and <code>Catwork.Service</code> constructors validate their shape, Fragments are loosely checked since they can be expanded, but Service is strictly checked.</p> <p>If you get this error, it means you've defined a key with the wrong type.</p> <pre><code>Catwork.Fragment {\n    Name = 0 -- &lt; this causes an error\n\n    ---\n    Name = \"Cat\" -- &lt; this is ok\n}\n</code></pre>"},{"location":"reference/errors/#bad_template","title":"BAD_TEMPLATE","text":"<ul> <li>Message: <code>Template %s does not exist for Service %*.</code></li> <li>Severity: <code>Error</code></li> </ul> <p>This error is emitted when you call <code>Service:CreateFragmentFromTemplate</code> using a string key representing a template that doesn't exist.</p> <p>Use Templates directly where possible</p> <p>Its safer to use templates directly, as referencing them by string can result in the template not being defined.</p> <p>Many services abstract the CreateFragmentFromTemplate function behind some other constructor, as this mechanism is fairly internal.</p>"},{"location":"reference/errors/#deprecated","title":"DEPRECATED","text":"<ul> <li>Message: <code>Function %q is deprecated. Use %q instead.</code></li> <li>Severity: <code>Warn</code></li> </ul> <p>The method is deprecated, and the alternative should be used.</p>"},{"location":"reference/errors/#dispatcher_already_spawned","title":"DISPATCHER_ALREADY_SPAWNED","text":"<ul> <li>Message: <code>Fragment %* has already been spawned.</code></li> <li>Severity: <code>Error</code></li> </ul> <p>This appears when you try to spawn a Fragment multiple times, if you're trying to capture the result of a Spawn call, use <code>Await</code> or <code>HandleAsync</code> instead.</p>"},{"location":"reference/errors/#dispatcher_destroyed_fragment","title":"DISPATCHER_DESTROYED_FRAGMENT","text":"<ul> <li>Message: <code>Fragment %* cannot be spawned because it has been destroyed.</code></li> <li>Severity: <code>Error</code></li> </ul> <p>This error is invoked when you try to spawn a destroyed Fragment, because destroyed Fragments dont appear in any of Catwork's internal storage tables, they cant be spawned.</p>"},{"location":"reference/errors/#dispatcher_spawn_err","title":"DISPATCHER_SPAWN_ERR","text":"<ul> <li>Message: <code>A fragment experienced an error while spawning: %s</code></li> <li>Severity: <code>Error</code></li> </ul> <p>Shown as a fail-state of the <code>xpcall</code> that <code>Service.Spawning</code> is wrapped into, you should try to track down this error in your own code.</p>"},{"location":"reference/errors/#duplicate_fragment","title":"DUPLICATE_FRAGMENT","text":"<ul> <li>Message: <code>Fragment %s is already defined</code></li> <li>Severity: <code>Error</code></li> </ul> <p>When using a static ID, they must be unique per service. You may have multiple Fragments with the same ID as long as they are not in the same Service.</p>"},{"location":"reference/errors/#duplicate_service","title":"DUPLICATE_SERVICE","text":"<ul> <li>Message: <code>Service %s is already defined.</code></li> <li>Severity: <code>Error</code></li> </ul> <p>Service names must be unique, this error is shown when you try to create an already existing Service.</p>"},{"location":"reference/errors/#fragment_self_await","title":"FRAGMENT_SELF_AWAIT","text":"<p>Future addition, not currently implemented</p> <ul> <li>Message: <code>Fragment %* is awaiting upon itself and will never resolve. Use HandleAsync instead.</code></li> <li>Severity: <code>Warn</code></li> </ul> <p>This is warned when you call <code>self:Await</code> inside an Init callback directly or indirectly, you should instead use <code>self:HandleAsync</code></p> BadBetter <pre><code>Init = function(self)\n    self:Await() -- this will never resolve\nend\n</code></pre> <pre><code>Init = function(self)\n    self:HandleAsync(function(ok, err)\n        -- this will resolve as it runs outside of the Init callback\n    end)\nend\n</code></pre>"},{"location":"reference/errors/#guid_ids_not_allowed","title":"GUID_IDS_NOT_ALLOWED","text":"<ul> <li>Message: <code>Cannot use Fragment ID %s, a new ID has been generated.</code></li> <li>Severity: <code>Warn</code></li> </ul> <p>GUIDs cannot be used as static IDs, as this is the fallback state for non-static fragments. If you want to statically use a GUID identifier, add a prefix char such as <code>_</code>.</p>"},{"location":"reference/errors/#internal","title":"INTERNAL","text":"<ul> <li>Message: <code>Error: %*. This is likely a known internal error, please report it!</code></li> <li>Severity: <code>Error</code></li> </ul> <p>This only appears when a known internal error occurs, if this does appear, please report it and what you're doing, as it likely means we're trying to track down a bug.</p>"},{"location":"reference/errors/#service_duplicate_template","title":"SERVICE_DUPLICATE_TEMPLATE","text":"<ul> <li>Message: <code>Template %s already exists</code></li> <li>Severity: <code>Error</code></li> </ul> <p>Services store templates with string identifiers, and only one Template may exist per identifier.</p>"},{"location":"reference/errors/#service_no_templates","title":"SERVICE_NO_TEMPLATES","text":"<ul> <li>Message: <code>Service %* does not implement templates.</code></li> <li>Severity: <code>Error</code></li> </ul> <p>The service is not a TemplateService, and as such, <code>Service.Template</code> cannot be used on it.</p> <p>Tip</p> <p>If you're trying to create a TemplateService, you can auto-enable them either through the existence of a <code>TemplateAdded</code> callback, or you can explicitly enable it with <code>EnableTemplates</code></p> <pre><code>return Catwork.Service {\n    EnableTemplates = true -- explicit definition\n\n    TemplateAdded = function() -- implicit definition\n}\n</code></pre>"},{"location":"reference/errors/#unknown","title":"UNKNOWN","text":"<ul> <li>Message: <code>Unknown Error</code></li> <li>Severity: <code>Error</code></li> </ul> <p>The internal error emitter was called with an invalid identifier. Please report this if it happens.</p>"},{"location":"reference/catwork/","title":"Catwork","text":"<p>Catwork refers to the root object that is returned when the module is required</p> <pre><code>require(path.to.catwork)\n</code></pre>"},{"location":"reference/catwork/#properties","title":"Properties","text":""},{"location":"reference/catwork/#catworkfragments","title":"Catwork.Fragments","text":"<p><code>{[string]: Fragment&lt;any&gt;}</code></p> <p>A table of fragments currently loaded inside the Catwork module. Destroyed fragments do not appear in this table.</p>"},{"location":"reference/catwork/#catworkservices","title":"Catwork.Services","text":"<p><code>{[string]: Service}</code></p> <p>A table of services currently loaded inside the Catwork module.</p>"},{"location":"reference/catwork/#catworkplugin","title":"Catwork.Plugin","text":"<p><code>Plugin?</code></p> <p>A reference to the plugin if applicable, this key is only defined if Catwork is running in a plugin context.</p>"},{"location":"reference/catwork/#catwork__version","title":"Catwork.__VERSION","text":"<p><code>string</code></p> <p>The current Catwork version.</p>"},{"location":"reference/catwork/#constructors","title":"Constructors","text":""},{"location":"reference/catwork/#catworkfragment","title":"Catwork.Fragment","text":"<p><code>&lt;A&gt;(params: A) -&gt; Fragment&lt;A&gt;</code></p> <p>Creates a new Fragment from the given parameters.</p> <p>Code Example:</p> <pre><code>return Catwork.Fragment {\n    Name = \"MeowService\",\n\n    Init = function(self)\n        print(\"meow!\")\n    end\n}\n</code></pre> <p>Tip</p> <p>From <code>0.4.4</code> onwards, you are able to define the ID explicitly using the <code>ID</code> key. These are known internally as <code>StaticFragments</code>.</p> <pre><code>Catwork.Fragment {\n    ID = \"MeowServiceStatic\"\n}\n</code></pre>"},{"location":"reference/catwork/#catworkservice","title":"Catwork.Service","text":"<p><code>(params) -&gt; Service</code></p> <p>Creates a service from a given parameter table. For more information, refer to the Services tutorial.</p>"},{"location":"reference/catwork/#methods","title":"Methods","text":""},{"location":"reference/catwork/#catworkcreatefragmentforservice","title":"Catwork:CreateFragmentForService","text":"<p><code>&lt;A&gt;(params: A, service: Service) -&gt; Fragment&lt;A&gt;</code></p> <p>Builds a Fragment for a given service, then returns it to the service's FragmentAdded callback.</p> <p>Warning</p> <p>Always call this method in a <code>Service.Fragment</code> definition, otherwise the fragment will never initialise.</p>"},{"location":"reference/catwork/#catworkgetfragmentsofname","title":"Catwork:GetFragmentsOfName","text":"<p><code>(name: string) -&gt; {[string]: Fragment&lt;any&gt;}</code></p> <p>Returns a list of fragments, or an empty table, of Fragments matching the given name.</p>"},{"location":"reference/catwork/#events","title":"Events","text":"<p>Note</p> <p>These events are designed for tracking object creation in debugging tools.</p>"},{"location":"reference/catwork/#catworkfragmentadded","title":"Catwork.FragmentAdded","text":"<p><code>Event&lt;Fragment&lt;any&gt;&gt;</code></p> <p>Fired when a Fragment is created through <code>CreateFragmentForService</code>.</p>"},{"location":"reference/catwork/#catworkfragmentremoved","title":"Catwork.FragmentRemoved","text":"<p><code>Event&lt;Fragment&lt;any&gt;&gt;</code></p> <p>Fired when a Fragment is destroyed.</p>"},{"location":"reference/catwork/#catworkserviceadded","title":"Catwork.ServiceAdded","text":"<p><code>Event&lt;Service&gt;</code></p> <p>Fired when a new service is created.</p>"},{"location":"reference/catwork/#catworktemplateadded","title":"Catwork.TemplateAdded","text":"<p><code>Event&lt;Template&gt;</code></p> <p>Fired when a new template is created.</p>"},{"location":"reference/catwork/fragment/","title":"Fragment","text":"<p>The basic building block of all running Catwork code.</p> <p>Note</p> <p>Due to the dynamic nature of Fragments, this documentation only describes the built-in logic.</p>"},{"location":"reference/catwork/fragment/#properties","title":"Properties","text":""},{"location":"reference/catwork/fragment/#fragmentfullid","title":"Fragment.FullID","text":"<p><code>string</code></p> <p>The full unique ID of the <code>Fragment</code>, this combines the <code>Fragment.ID</code> and <code>Service.Name</code> properties in the format:</p> <pre><code>{serviceName}_{fragmentID}\n</code></pre>"},{"location":"reference/catwork/fragment/#fragmentid","title":"Fragment.ID","text":"<p><code>string</code></p> <p>The unique ID of the Fragment. This will either be a GUID or a static fragment ID. This ID is only unique to the <code>Service</code> the <code>Fragment</code> is contained in.</p>"},{"location":"reference/catwork/fragment/#fragmentname","title":"Fragment.Name","text":"<p><code>string</code></p> <p>A non-unique identifier for this Fragment.</p>"},{"location":"reference/catwork/fragment/#fragmentservice","title":"Fragment.Service","text":"<p><code>Service</code></p> <p>A reference to the <code>Service</code> this <code>Fragment</code> is contained inside.</p>"},{"location":"reference/catwork/fragment/#fragmenttemplate","title":"Fragment.Template","text":"<p><code>Template</code></p> <p>A reference to the <code>Template</code> (if any), this <code>Fragment</code> was created with.</p>"},{"location":"reference/catwork/fragment/#callbacks","title":"Callbacks","text":"<p>These are built-in lifecycle callbacks that you can define in your Fragment. They are generally defined as the following syntax in <code>Catwork.Fragment</code>:</p> <pre><code>Catwork.Fragment {\n    Init = function(self)\n\n    end\n}\n</code></pre>"},{"location":"reference/catwork/fragment/#fragmentdestroying","title":"Fragment.Destroying","text":"<p><code>Destroying = function(self)</code></p> <p>Invoked when <code>Fragment:Destroy</code> is called, this is fired after it has been removed from all relevent tables, but before <code>Service.FragmentRemoved</code> is called.</p>"},{"location":"reference/catwork/fragment/#fragmentinit","title":"Fragment.Init","text":"<p>Defined as <code>Init = function(self)</code></p> <p>The callback that is invoked when a Fragment is spawned using <code>Fragment:Spawn</code>.</p> <p>Caution</p> <p>This is the default behaviour when <code>Service.Spawning</code> isn't overloaded, if you have overloaded it, make sure that the Init callback is eventually called for feature parity with the native service. (If you want that of course)</p>"},{"location":"reference/catwork/fragment/#methods","title":"Methods","text":""},{"location":"reference/catwork/fragment/#fragmentawait","title":"Fragment:Await","text":"<p><code>() -&gt; (boolean, string?)</code></p> <p>Waits for the <code>Service.Spawning</code> callback to finish on the <code>Fragment</code>, then returns the result of the wrapped <code>xpcall</code>.</p> <p>Don't self-await</p> <p>Be careful to not call self:Await directly or indirectly while <code>Init</code> is performing, this will cause the fragment to never resolve. This is bad!</p> <p>Future versions of Catwork should warn against this.</p> BadBetter <pre><code>Init = function(self)\n    self:Await() -- this will never resolve\nend\n</code></pre> <pre><code>Init = function(self)\n    self:HandleAsync(function(ok, err)\n        -- this will resolve as it runs outside of the Init callback\n    end)\nend\n</code></pre>"},{"location":"reference/catwork/fragment/#fragmentdestroy","title":"Fragment:Destroy","text":"<p><code>() -&gt; ()</code></p> <p>Destroys the Fragment. This clears it from all internal tables, fires <code>Fragment.Destroying</code>, and finally <code>Service.FragmentRemoved</code>.</p> <p>This method can be called multiple times, but will only operate once.</p>"},{"location":"reference/catwork/fragment/#fragmenthandleasync","title":"Fragment:HandleAsync","text":"<p><code>(asyncHandler: (boolean, string?) -&gt; ()?) -&gt; ()</code></p> <p>Waits for the Fragment to complete asynchronously, then calls the <code>asyncHandler</code>.</p> <p>This method is safe to call inside <code>Fragment.Init</code> as it runs in a seperate thread and does not block the execution of the Init call.</p>"},{"location":"reference/catwork/fragment/#fragmentspawn","title":"Fragment:Spawn","text":"<p><code>(xpcallHandler: ((string?) -&gt; string)?) -&gt; (boolean, string?)</code></p> <p>Spawns the Fragment, and uses <code>xpcallHandler</code> as the second arg inside <code>xpcall</code>.</p> <p>Make sure to return a string in your xpcall handler, otherwise, no error will be passed to the result handler.</p> <p>This function doesn't return</p> <p>Although this type is defined as <code>-&gt; (boolean, string?)</code>, it does not return anything in <code>v0.4.4</code>, this is being fixed in future releases.</p>"},{"location":"reference/catwork/service/","title":"Service","text":"<p>Services are singletons that let you change how Fragments behave.</p> TemplateServices are now implicit <p>Catwork previously had an explicit method called <code>Catwork.TemplateService</code>, this has since been removed. You now simply need to use one of two methods to enable templates</p> ExplicitImplicit <pre><code>return Catwork.Service {\n    EnableTemplates = true\n}\n</code></pre> <pre><code>return Catwork.Service {\n    TemplateAdded = function(self, template)\n\n    end\n}\n</code></pre>"},{"location":"reference/catwork/service/#properties","title":"Properties","text":""},{"location":"reference/catwork/service/#serviceenabletemplates","title":"Service.EnableTemplates","text":"<p><code>boolean</code></p> <p>Dictates if the service is a TemplateService, and that methods such as <code>Template</code> can be used.</p> <p>Assume template methods are undefined if this property is <code>false</code></p> <p>This setting disables all template logic, however, some objects may be left over such as the <code>Service.Templates</code> table.</p>"},{"location":"reference/catwork/service/#servicefragments","title":"Service.Fragments","text":"<p><code>{[string]: Fragment&lt;any&gt;}</code></p> <p>A table representing which fragments belong to this specific Service, these are stored the same way as Catwork.Fragments(1).</p> <ol> <li>Fragments are stored using the format    <code>{Fragment.Service.Name}_{Fragment.ID}</code></li> </ol>"},{"location":"reference/catwork/service/#servicefragmentnamestore","title":"Service.FragmentNameStore","text":"<p><code>{[string]: {[string]: Fragment&lt;any&gt;}}</code></p> <p>An internal storage tree for <code>Service.GetFragmentsOfName</code>.</p> <p>Do not use this property externally</p> <p>This table is unpredictable, it is safer to use <code>GetFragmentsOfName</code> as this returns an immutable chunk of this data</p>"},{"location":"reference/catwork/service/#servicetemplates","title":"Service.Templates","text":"<p><code>{[string]: Template}</code></p> <p>A storage table of this service's templates.</p>"},{"location":"reference/catwork/service/#callbacks","title":"Callbacks","text":"<p>These are built-in lifecycle callbacks that you can define in your Service. They are generally defined as the following syntax in <code>Catwork.Service</code>:</p> <pre><code>Catwork.Service {\n    Fragment = function(self, params)\n\n    end\n}\n</code></pre>"},{"location":"reference/catwork/service/#servicefragment","title":"Service.Fragment","text":"<p>Defined as <code>Fragment = function(self, params)</code></p> <p>The main method for constructing fragments out of the service. This method is provided with a list of parameters that are then built into a Fragment.</p> <pre><code>Fragment = function(self, params)\n    function params:Meow()\n        return \"meow!!!\"\n    end\n\n    return Catwork:CreateFragmentForService(params, self)\nend\n</code></pre> <p>This is eventually transformed into the method <code>Service:Fragment</code>.</p> <p>You MUST call <code>CreateFragmentForService</code></p> <p>This method links up everything internal related to the fragment, and must be called once in your <code>Fragment</code> callback definition.</p>"},{"location":"reference/catwork/service/#servicefragmentadded","title":"Service.FragmentAdded","text":"<p>Defined as <code>FragmentAdded = function(self, Fragment&lt;any&gt;)</code></p> <p>This method is invoked just after a <code>CreateFragmentForService</code> call, and represents the actual Fragment, and not just a tree of constructed parameters.</p> <p>This callback is intended for setting up code around the fragment, instead of enforcing it's shape.</p>"},{"location":"reference/catwork/service/#servicefragmentremoved","title":"Service.FragmentRemoved","text":"<p>Defined as <code>FragmentRemoved = function(self, Fragment&lt;any&gt;)</code></p> <p>Invoked after a Fragment has been destroyed, this method should be used for definining internal cleanup logic.</p>"},{"location":"reference/catwork/service/#servicespawning","title":"Service.Spawning","text":"<p>Defined as <code>Spawning = function(self, Fragment&lt;any&gt;)</code></p> <p>The asynchronous entry point that is called when <code>Fragment:Spawn</code> is called. Since this callback executed asynchronously, it is safe to perform stateful code here as it's escaped from the declarative callbacks of <code>Fragment</code> and <code>FragmentAdded</code>.</p> Fragment, FragmentAdded or Spawning? <p><code>Service.Fragment</code> should be used for setting up the Fragment itself, but should not perform any runtime behaviour.</p> <p><code>Service.FragmentAdded</code> should react to constructed fragments, and may perform simple runtime actions that do not require state. FragmentAdded should also (but does not have to) call <code>Spawn</code>.</p> <p><code>Service.Spawning</code> runs in an asynchronous thread, and stateful runtime behaviour should be performed here.</p>"},{"location":"reference/catwork/service/#servicetemplateadded","title":"Service.TemplateAdded","text":"<p>Defined as <code>TemplateAdded = function(self, Template)</code></p> <p>Invoked when a new Template is added through <code>Service:Template</code>. The definition of this key implicitly enables <code>TemplateServices</code>.</p>"},{"location":"reference/catwork/service/#methods","title":"Methods","text":""},{"location":"reference/catwork/service/#servicecreatefragmentfromtemplate","title":"Service:CreateFragmentFromTemplate","text":"<p><code>&lt;A&gt;(Template|string, A) -&gt; Fragment&lt;A&gt;</code></p> <p>Creates a fragment from a given template, or template identifier. This function will error if the template identifier is nil.</p> <p>Dont give this templates from other services</p> <p>This creates undefined behaviour, keep templates to their own service.</p>"},{"location":"reference/catwork/service/#servicegetfragmentsofname","title":"Service:GetFragmentsOfName","text":"<p><code>(name: string) -&gt; {[string]: Fragment&lt;A&gt;}</code></p> <p>Returns an immutable chunk from <code>Service.FragmentNameStore</code>, of all fragments defined with the given name. Keys of the return table are full fragment IDs(1) of each fragment.</p> <ol> <li>Fragments are stored using the format    <code>{Fragment.Service.Name}_{Fragment.ID}</code></li> </ol>"},{"location":"reference/catwork/service/#servicetemplate","title":"Service:Template","text":"<p><code>(TemplateParams) -&gt; Template</code></p> <p>Builds a template from the given params table.</p> <pre><code>Service:Template {\n    Name = \"CatGenerator\",\n    CreateFragment = function(self, fragment)\n\n    end\n}\n</code></pre>"},{"location":"reference/catwork/template/","title":"Template","text":"<p>Templates are small factory objects that create Fragments. Unlike other objects, they are incredibly simple.</p>"},{"location":"reference/catwork/template/#properties","title":"Properties","text":""},{"location":"reference/catwork/template/#templatename","title":"Template.Name","text":"<p><code>string</code></p> <p>The unique identifier for the template, each Service may only have one template of the given name.</p>"},{"location":"reference/catwork/template/#templateservice","title":"Template.Service","text":"<p><code>Service</code></p> <p>The service this template originates from, and should be the only service you create it with.</p>"},{"location":"reference/catwork/template/#methods","title":"Methods","text":""},{"location":"reference/catwork/template/#templatecreatefragment","title":"Template:CreateFragment","text":"<p><code>&lt;A&gt;(A) -&gt; Fragment&lt;A&gt;</code></p> <p>Builds a Fragment using the template and given parameters, returns the Fragment after being created.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>The following section introduces Catwork in an easy-to-digest and learn manner.</p> <p>Note</p> <p>These tutorials are designed so you can jump around as you need to for different concepts, but build on ideas learnt in previous sections.</p> <p>If you get stuck, feel free to send me a message on the DevForum, or get help from the Roblox Open Source community discord server!</p>"},{"location":"tutorials/getting-started/basic-fragment/","title":"Basic Fragment","text":"<p>Lets go into a basic fragment, and explain how the model works.</p>"},{"location":"tutorials/getting-started/basic-fragment/#importing-catwork","title":"Importing Catwork","text":"<p>Each Fragment should first import Catwork.</p> <pre><code>local ReplicatedFirst = game:GetService(\"ReplicatedFirst\")\nlocal Catwork = require(ReplicatedFirst.Catwork)\n</code></pre> <p>Note</p> <p>This tutorial expects Catwork to be in <code>ReplicatedFirst</code>, make sure its there before following this tutorial</p> <p>Future tutorials will assume you're importing this.</p>"},{"location":"tutorials/getting-started/basic-fragment/#a-clock-counter","title":"A clock counter","text":"<p>For this tutorial, we're going to slowly build an API for interfacing with a simple real-time clock system.</p> <p>Add <code>Lighting</code> as an import after your <code>Catwork</code> import:</p> <pre><code>local Lighting = game:GetService(\"Lighting\") -- required for this tutorial\n</code></pre>"},{"location":"tutorials/getting-started/basic-fragment/#adding-basic-logic","title":"Adding Basic Logic","text":"<p>Lets create a basic Fragment that iterates the current Lighting time. To do this, we call the <code>Catwork.Fragment</code> constructor:</p> <pre><code>return Catwork.Fragment {\n    Name = \"LightingClockTime\",\n\n    Init = function(self)\n        while true do\n            task.wait(1)\n            Lighting.ClockTime += 1/60\n        end\n    end,\n}\n</code></pre> <p>If you run this script, you'll notice the clock slowly ticks forward.</p> Not Working? <p>Here's some possible reasons for your code not working.</p> <ol> <li>You've not imported Catwork, Lighting or ReplicatedFirst.</li> <li>You didn't include a Runtime, refer to Installation for that.</li> <li>There's a typo in your script.</li> </ol> <p>Lets explain how this constructor works.</p> <p>First, we give it the name <code>LightingClockTime</code>, this doesn't do much internally as Fragments use a different method for being uniquely identified, however, it helps us identify which Fragment we're working with.</p> <pre><code>    Name = \"LightingClockTime\n</code></pre> <p>After that, we add an Init callback, which indicates what should happen when the Fragment is ready to go.</p> <pre><code>    Init = function(self)\n        while true do\n            task.wait(1)\n            Lighting.ClockTime += 1/60\n        end\n    end,\n</code></pre>"},{"location":"tutorials/getting-started/basic-fragment/#adding-an-api","title":"Adding an API","text":"<p>The <code>Catwork.Fragment</code> constructor lets you define any logic you want to on the object, and have it passed to other code using it.</p> <p>Lets add a API to get the current clock time, and set a timezone offset. To do this, add two new methods directly to the constructor</p> <pre><code>return Catwork.Fragment {\n    Name = \"LightingClockTime\",\n\n    Init = function(self)\n        while true do\n            task.wait(1)\n            Lighting.ClockTime += 1/60\n        end\n    end,\n\n    GetClockTime = function(self)\n\n    end,\n\n    SetTimeZoneOffset = function(self, offset)\n\n    end\n}\n</code></pre> <p>We're also going to add an in-built timer, and offset, to the fragment as a property:</p> <pre><code>return Catwork.Fragment {\n    Name = \"LightingClockTime\",\n\n    Time = os.time(),\n    TimeZoneOffset = 0\n</code></pre> <p>Now, lets implement our two new methods, firstly, <code>GetClockTime</code>. This method should just return <code>self.Time</code>:</p> <pre><code>    GetClockTime = function(self)\n        return self.Time\n    end\n</code></pre> <p>And, for <code>SetTimeZoneOffset</code>, this should change <code>self.TimeZoneOffset</code></p> <pre><code>    SetTimeZoneOffset = function(self, offset)\n        self.TimeZoneOffset = offset\n    end\n</code></pre>"},{"location":"tutorials/getting-started/basic-fragment/#updating-init","title":"Updating Init","text":"<p>If you run the project, and interface with the Fragment, you may notice that nothing happens. This is because we haven't updated our <code>Init</code> callback.</p> <p>Here's the updated Init callback: <pre><code>    Init = function(self)\n        while true do\n            Lighting.ClockTime = ((self.Time / 3600) % 24) + self.TimeZoneOffset\n            task.wait(1)\n        end\n    end\n</code></pre></p> <p>If you run the game now, the time in-game should match near to your local computer time. (If you computer is set to UTC.).</p>"},{"location":"tutorials/getting-started/basic-fragment/#using-the-api","title":"Using the API","text":"<p>If you used a ModuleScript, you can now require your script within another script, and interface with the clock counter. Here's a script that requires in the ClockCounter script, and prints out the clock time every second:</p> <pre><code>local ClockCounter = require(path.to.ClockCounter)\n\nwhile true do\n    print(ClockCounter:GetClockTime())\n    task.wait(1)\nend\n</code></pre>"},{"location":"tutorials/getting-started/basic-fragment/#asynchronous-design","title":"Asynchronous design","text":"<p>Catwork utilises a simple asynchronous dependency system, through <code>Fragment:Await</code> and <code>Fragment:HandleAsync</code>.</p> <p>This works by waiting until a Fragment's <code>Init</code> function completes (returns) then resumes any code waiting for it complete. You may notice an issue with our <code>Init</code> callback, in that it never returns, and so any code waiting on it will also never resume.</p> <p>Lets fix our Init callback to address this. We're going to use <code>task.spawn</code> to create a new thread within our <code>Init</code> callback, that runs independently of any code waiting upon it.</p> <pre><code>    Init = function(self)\n        task.spawn(function()\n            while true do\n                Lighting.ClockTime = ((self.Time / 3600) % 24) + self.TimeZoneOffset\n                task.wait(1)\n            end\n        end)\n    end\n</code></pre> <p>You should always <code>Await</code>/<code>HandleAsync</code> on Fragments, because you cannot guarantee that they are ready. The Service tutorial explains the Fragment:Spawn lifecycle more in depth.</p> <pre><code>local ClockCounter = require(path.to.ClockCounter)\nClockCounter:Await()\n\nwhile true do\n    print(ClockCounter:GetClockTime())\n    task.wait(1)\nend\n</code></pre>"},{"location":"tutorials/getting-started/installation/","title":"Installation","text":"<p>Catwork can be installed either as a Roblox model, or within a larger project inside your editor of choice.</p> <p>The following guide is different for within Roblox Studio, and within external editors.</p> Roblox StudioExternal <p>The RBXM can be obtained below. Its best to drag the module into <code>ReplicatedFirst</code>, unless you intend to use the tool as a plugin (which has its own section.)</p> <p>The tutorials expect Catwork to be placed in <code>ReplicatedFirst</code>.</p> <p> Download Catwork</p> <p>If you intend to use Catwork externally, the sourcecode can be found on the Releases page on the GitHub repository</p> <p>GitHub Releases</p> <p>Expected for Studio</p> <p>The tutorials expect you to use Catwork within Studio, but can somewhat be followed in your editor of choice, if you setup the project correctly.</p>"},{"location":"tutorials/getting-started/installation/#obtaining-a-runtime","title":"Obtaining a Runtime","text":"<p>Catwork does not come bundled with a Runtime, which is an intentional choice for the time being.</p> <p>CollectionService Runtime (RECOMENDED)</p> <p>This runtime loads ModuleScripts with a given tag based on the context it is running in.</p> Game ContextPlugin Context <pre><code>local CollectionService = game:GetService(\"CollectionService\")\nlocal RunService = game:GetService(\"RunService\")\n\nlocal TAG_SHARED = \"SharedFragment\"\nlocal TAG_LOCAL = if RunService:IsClient() then \"ClientFragment\" else \"ServerFragment\"\nlocal passed, failed = 0, 0\n\nlocal function safeRequire(module)\n    local success, result = pcall(require, module)\n    if success then\n        passed += 1\n        return result\n    else\n        warn(\"Error when requiring\", module, \":\", result)\n        failed += 1\n        return nil\n    end\nend\n\nlocal function loadGroup(tag)\n    local m = CollectionService:GetTagged(tag)\n    for _, mod in m do\n        if mod:IsA(\"ModuleScript\") then\n            safeRequire(mod)\n        end\n    end\nend\n\nlocal t = os.clock()\nloadGroup(TAG_LOCAL)\nloadGroup(TAG_SHARED)\nlocal f = os.clock() - t\n\nprint(`\ud83d\udc08 CatworkRun. {passed} modules required, {failed} modules failed. Load time: {math.round(f * 1000)}ms`)\n</code></pre> <pre><code>local CollectionService = game:GetService(\"CollectionService\")\nif not plugin then return end\n\nlocal TAG = \"PluginFragment\"\n\nlocal function safeRequire(module)\n    local success, result = pcall(require, module)\n    if success then\n        return result\n    else\n        warn(\"Error when requiring\", module, \":\", result)\n        return nil\n    end\nend\n\nlocal function loadGroup(tag)\n    local m = CollectionService:GetTagged(tag)\n    for _, mod in m do\n        if mod:IsDescendentOf(plugin) and mod:IsA(\"ModuleScript\") then\n            safeRequire(mod)\n        end\n    end\nend\n\nloadGroup(TAG)\n</code></pre> <p>You should generally use this runtime where possible as it's configured from CollectionService tags, and doesn't require you to fiddle with the script.</p>"},{"location":"tutorials/services/","title":"Services","text":"<p>Services are singleton objects that control Fragments under them. For this guide, we're going to explain how Fragments work under Services, then make a simple <code>RemoteEvent</code> handler.</p>"},{"location":"tutorials/services/#defining-a-service","title":"Defining a Service","text":"<p><code>Service</code>s are defined using <code>Catwork.Service</code></p> <pre><code>Catwork.Service {\n    Name = \"RemoteHandler\"\n}\n</code></pre> <p>Each service requires a unique name, that is not taken up by another Service.</p>"},{"location":"tutorials/services/#fragments","title":"Fragments","text":""},{"location":"tutorials/services/#creating-fragment","title":"Creating Fragment","text":"<p><code>Fragment</code> objects are created through the <code>Fragment</code> callback, at this step, you can manipulate the Fragment by adding new methods, or validating parameters.</p> <pre><code>    Fragment = function(self, params)\n        return Catwork:CreateFragmentForService(params, self)\n    end\n</code></pre> <p>You must call <code>CreateFragmentForService</code></p> <p>This is required as this tells Catwork it can create the Fragment internally. From this point, you should assume the Fragment is ready and shouldn't be touched further (outside of Spawning.)</p> <p>For example, here, we add a simple method to the Fragment to print <code>meow</code>:</p> <pre><code>    Fragment = function(self, params)\n        function params:Meow()\n            print(\"meow!\")\n        end\n\n        return Catwork:CreateFragmentForService(params, self)\n    end\n</code></pre> <p>Created fragment is the same table as params</p> <p>This means you can operate upon <code>params</code> as if it were the Fragment, though you should really do this in <code>FragmentAdded</code></p>"},{"location":"tutorials/services/#reacting-to-new-fragments","title":"Reacting to new Fragments","text":"<p><code>FragmentAdded</code> is the callback that is invoked straight after <code>CreateFragmentForService</code>, this defines behaviour that should react around the Fragment. Please note that we still assume the Fragment is in a declarative phase at this point, so avoid runtime logic.</p> <p>Note</p> <p><code>Fragment:Spawn</code> is the intended way for Fragments to escape the declarative state phase.</p> <p>You can either <code>Spawn</code> directly from this callback, or defer it to another system.</p> <pre><code>    FragmentAdded = function(self, Fragment)\n        print(`New Fragment: {fragment.Name}`)\n        Fragment:Spawn()\n    end\n</code></pre>"},{"location":"tutorials/services/#changing-spawn-logic","title":"Changing <code>Spawn</code> logic","text":"<p>When <code>Fragment:Spawn</code> is called, the internal Dispatcher looks for the Service's spawning callback, which tells the Service that it should act upon this Fragment.</p> <p>This function is asynchronous, and wont block the operation of other code. By default, this simply just calls Init on the fragment, but at this point, the Fragment has escaped its declarative state, and runtime code can now be operated upon it.</p> <pre><code>    Spawning = function(self, Fragment)\n        if Fragment.Init then\n            Fragment:Init()\n        end\n    end\n</code></pre>"},{"location":"tutorials/services/#basic-lifecycle-graph","title":"Basic Lifecycle Graph","text":"<p>The following graph explains the default behaviour of a Fragment, from <code>Service.Fragment</code> to <code>Fragment:Init</code></p> <pre><code>    flowchart TB\n    A[\"Service.Fragment\"]\n    B[\"CreateFragmentForService\"]\n    C[\"FragmentAdded\"]\n    D[\"Fragment:Spawn\"]\n    E[\"Spawning\"]\n    F[\"Fragment:Init\"]\n\n\n    A---&gt;B\n    B---|Internal Fragment Constructor|C\n    C---&gt;D\n    D---|Internal Dispatcher|E\n    E---&gt;F</code></pre>"},{"location":"tutorials/services/example/","title":"Example Service","text":"<p>The following guide explains how to create a simple RemoteEventHandler service, and how to use it.</p>"},{"location":"tutorials/services/example/#remote-handler","title":"Remote Handler","text":"<p>First, lets define our Service.</p> <pre><code>return Catwork.Service {\n    Name = \"RemoteEventHandler\"\n}\n</code></pre>"},{"location":"tutorials/services/example/#building-the-fragment","title":"Building the Fragment","text":"<p>Next, we'll create the <code>Fragment</code> constructor:</p> <pre><code>    Fragment = function(self, params)\n        if not params.ID then\n            error(\"Fragment requires a static identifier\")\n        end\n\n        if not params.Event then\n            error(\"Fragment requires a connectable event\")\n        end\n\n        return Catwork:CreateFragmentForService(params, self)\n    end\n</code></pre> <p>This <code>Fragment</code> constructor simply enforces that the Fragment has an ID, and an Event callback.</p> <p>We dont need to define any special logic for <code>FragmentAdded</code> here, since all remaining logic escapes the declarative phase. Though, for example, if you wanted to defer Spawning so another system can take over, you can simply add this:</p> <pre><code>    FragmentAdded = function(self, Fragment)\n        RemoteDispatcher:queue(Fragment)\n    end\n</code></pre> <p>Because we're overloading the default <code>FragmentAdded</code>, the Fragment wont spawn unless we tell it to.</p>"},{"location":"tutorials/services/example/#setting-up-the-remote","title":"Setting up the Remote","text":"<p>Within our <code>Spawning</code> callback, we create the remote, and hook it to the event:</p> <pre><code>    Spawning = function(self, Fragment)\n        local remote = Instance.new(\"RemoteEvent\")\n\n        remote.Event = function(...)\n            Fragment:Event(...)\n        end\n\n        remote.Name = Fragment.ID\n        remote.Parent = ReplicatedStorage\n    end\n</code></pre> <p>Note</p> <p>This assumes you've made a reference to <code>ReplicatedStorage</code></p>"},{"location":"tutorials/services/example/#using-the-remote-handler","title":"Using the Remote Handler","text":"<p>In another script, lets require in the RemoteHandler service, and create a Fragment:</p> <pre><code>local RemoteEventHandler = require(path.to.RemoteEventHandler)\n\nRemoteEventHandler:Fragment {\n    ID = \"Meowitzer\",\n\n    Event = function(self, plr)\n        print(`meows at {plr.Name} cutely`)\n    end\n}\n</code></pre> <p>If you run the game, a new Event should appear called <code>Meowitzer</code>, if you <code>FireServer</code> it, it'll print the requested message.</p>"},{"location":"tutorials/services/template-services/","title":"TemplateService","text":"TemplateServices are now implicit <p>Catwork previously had an explicit method called <code>Catwork.TemplateService</code>, this has since been removed. You now simply need to use one of two methods to enable templates</p> ExplicitImplicit <pre><code>return Catwork.Service {\n    EnableTemplates = true\n}\n</code></pre> <pre><code>return Catwork.Service {\n    TemplateAdded = function(self, template)\n\n    end\n}\n</code></pre> <p>TemplateServices are an extension to Services that allow them to create Templates. Templates are small objects that can be used to create lots of Fragments with a similar shape.</p> <p>Note</p> <p>The name <code>TemplateService</code> refers to an older implementation of this feature, Template methods are now simply mounted directly to a Service object if it detects that it is one.</p>"},{"location":"tutorials/services/template-services/#template","title":"Template","text":""},{"location":"tutorials/services/template-services/#defining-a-template","title":"Defining a Template","text":"<p>Templates can be defined with the <code>Service:Template</code> constructor</p> <pre><code>Service:Template {\n    Name = \"Template\",\n    CreateFragment = function(_, self)\n\n    end\n}\n</code></pre> <p>This creates a unique <code>Template</code> for the service, the <code>CreateFragment</code> callback is fired when creating a new <code>Fragment</code> against the <code>Template</code>.</p>"},{"location":"tutorials/services/template-services/#creating-a-template","title":"Creating a Template","text":"<p>To create a Template, you use <code>Service:CreateFragmentFromTemplate</code>, although, many Services omit this externally, opting to use an abstraction.</p> <pre><code>Service:CreateFragmentFromTemplate(template, {\n    -- initial parameters\n})\n</code></pre> <p>Dont give this templates from other services</p> <p>This creates undefined behaviour, keep templates to their own service.</p> <p>The following graph explains the lifecycle of Template construction:</p> <pre><code>    flowchart LR\n    A[\"Service:CreateFragmentFromTemplate\"]\n    B[\"CreateFragment\"]\n    C[\"Service.Fragment\"]\n    D[\"Fragment Construction\"]\n\n    A---&gt;B\n    B---&gt;C\n    C-.-&gt;D</code></pre>"},{"location":"tutorials/services/template-services/#templateadded","title":"TemplateAdded","text":"<p>To react to when new Templates are created, you can add a <code>TemplateAdded</code> callback to your Service:</p> <pre><code>Catwork.Service {\n    ...\n\n    TemplateAdded = function(self, Template)\n        print(`new template: {Template.Name}`)\n    end\n}\n</code></pre> <p>The existence of this callback tells Catwork this is a TemplateService, though you can also explicitly tell it that the Service is one through <code>EnableTemplates</code></p> <pre><code>Catwork.Service {\n    Name = \"SomeService\",\n    EnableTemplates = true\n}\n</code></pre>"}]}